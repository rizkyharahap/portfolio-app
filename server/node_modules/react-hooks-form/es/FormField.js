(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "react", "prop-types", "./hooks"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("react"), require("prop-types"), require("./hooks"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.react, global.propTypes, global.hooks);
    global.FormField = mod.exports;
  }
})(this, function (_exports, _react, _propTypes, _hooks) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  _propTypes = _interopRequireDefault(_propTypes);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

  function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

  function FormField(props) {
    var component = props.component,
        overrideFormName = props.formName,
        fieldName = props.name,
        rest = _objectWithoutProperties(props, ["component", "formName", "name"]);

    var form = (0, _hooks.useFormApi)(overrideFormName);
    var fieldValue = (0, _hooks.useFormFieldValue)(fieldName);
    var formName = form.getName();
    (0, _react.useLayoutEffect)(function () {
      return form.registerField(fieldName, props);
    }, [formName, fieldName]);
    var handleBlur = (0, _react.useCallback)(function () {
      form.blurField(fieldName);
    }, [formName, fieldName]);
    var handleChange = (0, _react.useCallback)(function (payload) {
      if (typeof component !== 'string') {
        form.changeFieldValue(fieldName, payload);
      } else if (props.type === 'checkbox') {
        form.changeFieldValue(fieldName, payload.target.checked);
      } else if (props.type === 'radio') {
        form.changeFieldValue(fieldName, payload.target.checked ? props.value : undefined);
      } else if (component === 'select' && props.multiple) {
        var options = payload.target.options;
        var selectedOptions = [];

        for (var i = 0; i < options.length; i++) {
          if (options[i].selected) {
            selectedOptions.push(options[i].value);
          }
        }

        form.changeFieldValue(fieldName, selectedOptions);
      } else {
        form.changeFieldValue(fieldName, payload.target.value);
      }
    }, [formName, fieldName, component, props.type]);
    var handleFocus = (0, _react.useCallback)(function () {
      form.focusField(fieldName);
    }, [formName, fieldName]);

    var componentProps = _objectSpread({}, rest, {
      name: fieldName,
      onBlur: handleBlur,
      onChange: handleChange,
      onFocus: handleFocus
    });

    if (typeof component !== 'string') {
      componentProps.formName = formName;
      componentProps.value = fieldValue;
    }

    if (component === 'select' && props.multiple) {
      componentProps.value = fieldValue || [];
    }

    if (component === 'input') {
      if (props.type === 'checkbox') {
        componentProps.checked = !!fieldValue;
      } else if (props.type === 'radio') {
        componentProps.checked = fieldValue === props.value;
      } else if (props.type !== 'file') {
        if (typeof fieldValue === 'undefined') {
          componentProps.value = '';
        } else {
          componentProps.value = fieldValue;
        }
      }
    }

    return (0, _react.createElement)(component, componentProps);
  }

  FormField.propTypes = {
    component: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.func, _propTypes.default.object]).isRequired,
    formName: _propTypes.default.string,
    name: _propTypes.default.string.isRequired
  };

  var _default = (0, _react.memo)(FormField);

  _exports.default = _default;
});